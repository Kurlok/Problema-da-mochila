# -*- coding: utf-8 -*-
"""mochila.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZkQqUFiIs875RzjfSo69vib1yeMEC4rf
"""

import numpy as npy
import random as rd
import matplotlib.pyplot as plt

#Definindo as variáveis

#mochila_peso_max = int(input("Digite o peso máximo que a mochila aguenta:\n"))
mochila_peso_max = 300
#qtd_itens = int(input("Digite a quantidade de itens que serão combinadas para colocar na mochila:\n"))
qtd_itens = 10

#peso_item_min = int(input("Digite o peso mínimo para o item:\n"))
peso_item_min = 10

#peso_item_max  = 0
#while peso_item_max  < peso_item_min:
#  peso_item_max  = int(input("Digite o peso máximo para o item:\n"))
#  if peso_item_max  < peso_item_min:
#    print('O peso máximo do item não pode ser inferior ao peso mínimo') 
peso_item_max = 100

#valor_item_min = int(input("Digite o valor mínimo para o item:\n"))
valor_item_min = 15

#valor_item_max = 0;
#while valor_item_max < valor_item_min:
#  valor_item_max = int(input("Digite o valor máximo para o item:\n"))
#  if valor_item_max < valor_item_min:
#    print('O valor máximo do item não pode ser inferior ao valor mínimo') 
valor_item_max = 150

#Vetor com o número do item
n_item = npy.arange(1,qtd_itens+1)

#Vetores com os pesos e valores aleatórios para cada item
peso = npy.random.randint(peso_item_min, peso_item_max, size = qtd_itens)
valor = npy.random.randint(valor_item_min, valor_item_max, size = qtd_itens)

#Definindo a população
#qtd_solucoes = int(input("Digite a quantidade de soluções:\n"))
qtd_solucoes = 4
populacao_tamanho = (qtd_solucoes, qtd_itens)
populacao_inicial = npy.random.randint(2, size = populacao_tamanho)
populacao_inicial = populacao_inicial.astype(int)
#Definindo o a quantidade de gerações
#qtd_geracoes = int(input("Digite a quantidade de gerações:\n"))
qtd_geracoes = 5
qtd_geracoes = qtd_geracoes
qtd_pais = 2

#Imprimindo as variáveis
print('PARAMÊTROS')
print('Peso máximo que a mochila é capaz de carregar: {}'.format(mochila_peso_max))
print('Quantidade de itens disponíveis: {}'.format(qtd_itens))
print('Peso mínimo que um item pode possuir: {}'.format(peso_item_min))
print('Peso máximo que um item pode possuir: {}'.format(peso_item_max))
print('Valor mínimo que um item pode possuir: {}'.format(valor_item_min))
print('Valor máximo que um item pode possuir: {}'.format(valor_item_max))
print('Quantidade de soluções por geração: {}'.format(qtd_solucoes))
print('Quantidade de gerações: {}'.format(qtd_geracoes))
print('Quantidade de pais: {}'.format(qtd_pais))
print('\nLISTA DE ITENS')
print('Nº Item   Peso      Valor')
for i in range(qtd_itens):
    print('{0}          {1}         {2}'.format(n_item[i], peso[i], valor[i]))
print('\nFUNÇÃO FITNESS\nSe o somatório de (peso do item * gene) para todos os genes da solução da geração for menor ou igual ao peso máximo que a mochila pode aguentar então o fitness é igual o somatório (valor do item * gene) (peso do item * gene) para todos os genes da solução. Caso contrário o fitness é igual a 0.')
print('\nGERAÇÕES (0 ou 1 significa se o item está presente ou não na solução):')

def calcula_fitness(peso, valor, geracao, peso_max, n_geracao):
    fitness = npy.empty(geracao.shape[0])
    melhor_solucao = 0 
    melhor_fitness = 0
    for i in range(geracao.shape[0]):
        soma_valor = npy.sum(geracao[i] * valor)
        soma_peso = npy.sum(geracao[i] * peso)
        if soma_peso <= peso_max:
            fitness[i] = soma_valor
        else:
            fitness[i] = 0
        if melhor_fitness < fitness[i]: 
            melhor_fitness = fitness[i]
            melhor_solucao = i+1
        print('Geração {0}, Solução {1}, Fitness: {2}'.format(n_geracao+1, i+1, fitness[i]))
    print('---- A melhor solução da geração {0} foi a nº {1} ----'.format(n_geracao+1, melhor_solucao))
    return fitness.astype(int)

# def selecao_ranking(fitness, qtd_pais, geracao):
#     fitness = list(fitness)
#     pais = npy.empty((qtd_pais, geracao.shape[1])) #geracao.shape[1] é equivalente a qtd_itens
#     for i in range(qtd_pais):
#         fitness_max_idx = npy.where(fitness == npy.max(fitness))
#         pais[i,:] = geracao[fitness_max_idx[0][0], :] #recebe a linha i
#     print('PAIS: {0}'.format(pais))
#     return pais

def selecao_roleta(fitness, qtd_pais, geracao):
    # fitness = list(fitness)
    fitness_total = npy.sum(fitness)
    print ('SELEÇÃO ROLETA')
    print ('Fitness Total da Geração: {}'.format(fitness_total))
    print ('Fitness das soluções da geração: {}'.format(fitness))
    n_roleta = npy.empty([fitness.size])
    for i in range(fitness.size):
        n_roleta[i] = round(fitness[i]/fitness_total, 4)
    n_roleta_ordenados = npy.sort(n_roleta)
    indices_roleta_ordenados = npy.argsort(n_roleta)
    i = 0
    print('Limites de números da roleta: {}'.format(n_roleta))
    print('Limites de números da roleta ordenados: {}'.format(n_roleta_ordenados))
    print('Indices de números da roleta ordenados: {}'.format(indices_roleta_ordenados))
    indice_selecionado_pai = 0
    pais = [] #geracao.shape[1] é equivalente a qtd_itens
    # pais = npy.empty((qtd_pais, geracao.shape[1])) #geracao.shape[1] é equivalente a qtd_itens
    for i in range(qtd_pais):
        sorteio_roleta = round(rd.random(),4)
        print('Nº Sorteado na roleta:{}'.format(sorteio_roleta))
        soma_roleta = 0 
        for j in range(fitness.size):
            if (n_roleta_ordenados[j] > 0):
                soma_roleta += n_roleta_ordenados[j]
                print ('soma_roleta: {}'.format(soma_roleta))
                print ('i: {}'.format(i))
                print ('j: {}'.format(j))
                print ('j+1: {}'.format(j+1))
                print ('fitness.size-1: {}'.format(fitness.size-1))
                print ('n_roleta_ordenados[j]: {}'.format(n_roleta_ordenados[j]))

                if (j+1 <= fitness.size-1):
                    print ('teste1:')
                    if (soma_roleta > n_roleta_ordenados[j]) and (soma_roleta < n_roleta_ordenados[j+1]):
                        print ('teste2:')
                        indice_selecionado_pai = npy.argsort(n_roleta[j])
                        print('indice_selecionado_pai: {}'.format(indice_selecionado_pai))
    return pais

def crossover_uniforme(geracao, pais):
    taxa_crossover = 0.8
    sorteio_crossover = rd.random()
    filho1 = [x for x in range(8)]
    filho2 = [x for x in range(8)],
    if taxa_crossover >= sorteio_crossover:
        filho1
    for i in range(range(pais.shape[1])):
        sorteio_gene_crossover = rd.randint(0,1)
        if(sorteio_gene_crossover == 1):
            filho1[i] = geracao[pai1][i]
            filho2[i] = geracao[pai2][i]
        elif(sorteio_gene_crossover == 0):
            filho1[i] = geracao[pai2][i]
            filho2[i] = geracao[pai1][i]
    #verifica se o número gerado é menor que a probabilidade

    
    return (filho1, filho2)


def crossover(pais, qtd_filhos):
    filhos = npy.empty((qtd_filhos, pais.shape[1])) #pais.shape[1] é equivalente que a qtd_pais
    crossover_ponto = int(pais.shape[1]/2)
    crossover_taxa = 0.8
    i=0
    print ('pais.shape[0] {}'.format(pais.shape[0]))
    print ('qtd_filhos {}'.format(qtd_filhos))
    while (pais.shape[0] < qtd_filhos):
        print ('pais_shape[i]{}')
        pai1_index = i%pais.shape[0]
        pai2_index = (i+1)%pais.shape[0]
        x = rd.random()
        if x > crossover_taxa:
            continue
        pai1_index = i%pais.shape[0]
        pai2_index = (i+1)%pais.shape[0]
        filhos[i,0:crossover_ponto] = pais[pai1_index,0:crossover_ponto]
        filhos[i,crossover_ponto:] = pais[pai2_index,crossover_ponto:]
        i=+1
    return filhos    


def mutacao(filhos):
    mutantes = npy.empty((filhos.shape))
    taxa_mutacao = 0.3
    for i in range(mutantes.shape[0]):
        random_valor = rd.random()
        mutantes[i,:] = filhos[i,:]
        if random_valor > taxa_mutacao:
            continue
        int_random_valor = rd.randint(0,filhos.shape[1]-1)    
        if mutantes[i,int_random_valor] == 0 :
            mutantes[i,int_random_valor] = 1
        else :
            mutantes[i,int_random_valor] = 0
    return mutantes   


def otimizar(peso, valor, geracao, qtd_solucoes, qtd_geracoes, qtd_pais, peso_max_mochila):
    parameters, fitness_historico = [], []
    #qtd_pais = int(populacao_tamanho[0]/2)
    #qtd_filhos = populacao_tamanho[0] - qtd_pais 
    qtd_filhos = qtd_solucoes - qtd_pais 
    for i in range(qtd_geracoes):
        print('\nGeração {0}: \n{1}'.format(i+1, geracao)) 
        fitness = calcula_fitness(peso, valor, geracao, peso_max_mochila, i)
        fitness_historico.append(fitness)
        pais = selecao_roleta(fitness, qtd_pais, geracao)
        # filhos = crossover(pais, qtd_filhos)
        # mutantes = mutacao(filhos)
        # geracao[0:pais.shape[0], :] = pais
        # geracao[pais.shape[0]:, :] = mutantes
        
    fitness_max = npy.where(fitness == npy.max(fitness))
    parameters.append(geracao[fitness_max[0][0],:])
    return parameters, fitness_historico


parameters, fitness_historico = otimizar(peso, valor, populacao_inicial, qtd_solucoes, qtd_geracoes, qtd_pais, mochila_peso_max)
print('A melhor solução encontrada para o problema foi: \n{}'.format(parameters))
selected_items = n_item * parameters


# fitness_media = [npy.mean(fitness) for fitness in fitness_historico]
# fitness_maximo = [npy.max(fitness) for fitness in fitness_historico]
# plt.plot(list(range(qtd_geracoes)), fitness_media, label = 'Fitness Médio')
# plt.plot(list(range(qtd_geracoes)), fitness_maximo, label = 'Fitness Máximo')
# plt.legend()
# plt.title('Fitness através das gerações')
# plt.xlabel('Gerações')
# plt.ylabel('Fitness')
# plt.show()
# print(npy.asarray(fitness_historico).shape)
