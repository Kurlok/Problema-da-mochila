# -*- coding: utf-8 -*-
"""mochila.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZkQqUFiIs875RzjfSo69vib1yeMEC4rf
"""

import numpy as npy
import pandas as pd
import random as rd
from random import randint
import matplotlib.pyplot as plt

#Definindo as variáveis

#mochila_peso_max = int(input("Digite o peso máximo que a mochila aguenta:\n"))
mochila_peso_max = 300
#qtd_itens = int(input("Digite a quantidade de itens que serão combinadas para colocar na mochila:\n"))
qtd_itens = 10

#peso_item_min = int(input("Digite o peso mínimo para o item:\n"))
peso_item_min = 10

#peso_item_max  = 0
#while peso_item_max  < peso_item_min:
#  peso_item_max  = int(input("Digite o peso máximo para o item:\n"))
#  if peso_item_max  < peso_item_min:
#    print('O peso máximo do item não pode ser inferior ao peso mínimo') 
peso_item_max = 100

#valor_item_min = int(input("Digite o valor mínimo para o item:\n"))
valor_item_min = 15

#valor_item_max = 0;
#while valor_item_max < valor_item_min:
#  valor_item_max = int(input("Digite o valor máximo para o item:\n"))
#  if valor_item_max < valor_item_min:
#    print('O valor máximo do item não pode ser inferior ao valor mínimo') 
valor_item_max = 150

#Vetor com o número do item
n_item = npy.arange(1,qtd_itens+1)

#Vetores com os pesos e valores aleatórios para cada item
peso = npy.random.randint(peso_item_min, peso_item_max, size = qtd_itens)
valor = npy.random.randint(valor_item_min, valor_item_max, size = qtd_itens)

#Definindo a população
#qtd_solucoes = int(input("Digite a quantidade de soluções:\n"))
qtd_solucoes = 4
populacao_tamanho = (qtd_solucoes, qtd_itens)
populacao_inicial = npy.random.randint(2, size = populacao_tamanho)
populacao_inicial = populacao_inicial.astype(int)
#Definindo o a quantidade de gerações
#qtd_geracoes = int(input("Digite a quantidade de gerações:\n"))
qtd_geracoes = 5
qtd_geracoes = qtd_geracoes

#Imprimindo as variáveis
print('PARAMÊTROS')
print('Peso máximo que a mochila é capaz de carregar: {}'.format(mochila_peso_max))
print('Quantidade de itens disponíveis: {}'.format(qtd_itens))
print('Peso mínimo que um item pode possuir: {}'.format(peso_item_min))
print('Peso máximo que um item pode possuir: {}'.format(peso_item_max))
print('Valor mínimo que um item pode possuir: {}'.format(valor_item_min))
print('Valor máximo que um item pode possuir: {}'.format(valor_item_max))
print('Quantidade de soluções por geração: {}'.format(qtd_solucoes))
print('Quantidade de gerações: {}'.format(qtd_geracoes))
print('\nLISTA DE ITENS')
print('Nº Item   Peso      Valor')
for i in range(qtd_itens):
    print('{0}          {1}         {2}'.format(n_item[i], peso[i], valor[i]))
print('\nFUNÇÃO FITNESS\nSe o somatório de (peso do item * gene) para todos os genes da solução da geração for menor ou igual ao peso máximo que a mochila pode aguentar então o fitness é igual o somatório (valor do item * gene) (peso do item * gene) para todos os genes da solução. Caso contrário o fitness é igual a 0.')
print('\nGERAÇÕES (0 ou 1 significa se o item está presente ou não na solução):')

#A função fitness é: Se o somatório de (peso do item * gene) para cada indíviduo da solução <= peso_max_mochila então o fitness é igual o somatório (valor do item * gene) da solução. Caso contrário fitness = 0
def calcula_fitness(peso, valor, populacao, peso_max, n_geracao):
    fitness = npy.empty(populacao.shape[0])
    melhor_solucao = 0 
    melhor_fitness = 0
    for i in range(populacao.shape[0]):
        soma_valor = npy.sum(populacao[i] * valor)
        soma_peso = npy.sum(populacao[i] * peso)
        if soma_peso <= peso_max:
            fitness[i] = soma_valor
        else:
            fitness[i] = 0
        if melhor_fitness < fitness[i]: 
            melhor_fitness = fitness[i]
            melhor_solucao = i+1
        print('Geração {0}, Solução {1}, Fitness: {2}'.format(n_geracao+1, i+1, fitness[i]))
    print('A melhor solução da geração {0} foi a solução nº {1}\n'.format(n_geracao+1, melhor_solucao))
    return fitness.astype(int)

def selecao(fitness, n_pais, populacao):
    fitness = list(fitness)
    pais = npy.empty((n_pais, populacao.shape[1]))
    for i in range(n_pais):
        fitness_max_idx = npy.where(fitness == npy.max(fitness))
        pais[i,:] = populacao[fitness_max_idx[0][0], :]
        fitness[fitness_max_idx[0][0]] = -999999
    return pais

def crossover(pais, qtd_filhos):
    filhos = npy.empty((qtd_filhos, pais.shape[1]))
    crossover_point = int(pais.shape[1]/2)
    crossover_rate = 0.8
    i=0
    while (pais.shape[0] < qtd_filhos):
        parent1_index = i%pais.shape[0]
        parent2_index = (i+1)%pais.shape[0]
        x = rd.random()
        if x > crossover_rate:
            continue
        parent1_index = i%pais.shape[0]
        parent2_index = (i+1)%pais.shape[0]
        filhos[i,0:crossover_point] = pais[parent1_index,0:crossover_point]
        filhos[i,crossover_point:] = pais[parent2_index,crossover_point:]
        i=+1
    return filhos    


def mutacao(filhos):
    mutantes = npy.empty((filhos.shape))
    taxa_mutacao = 0.3
    for i in range(mutantes.shape[0]):
        random_valor = rd.random()
        mutantes[i,:] = filhos[i,:]
        if random_valor > taxa_mutacao:
            continue
        int_random_valor = randint(0,filhos.shape[1]-1)    
        if mutantes[i,int_random_valor] == 0 :
            mutantes[i,int_random_valor] = 1
        else :
            mutantes[i,int_random_valor] = 0
    return mutantes   


def otimizar(peso, valor, geracao, qtd_solucoes, qtd_geracoes, peso_max_mochila):
    parameters, fitness_historico = [], []
    #qtd_pais = int(populacao_tamanho[0]/2)
    #qtd_filhos = populacao_tamanho[0] - qtd_pais 
    qtd_pais = int(qtd_solucoes/2)
    qtd_filhos = qtd_solucoes - qtd_pais 
    for i in range(qtd_geracoes):
        print('Geração {0}: \n{1}'.format(i+1, geracao)) 
        fitness = calcula_fitness(peso, valor, geracao, peso_max_mochila, i)
        fitness_historico.append(fitness)
        pais = selecao(fitness, qtd_pais, geracao)
        filhos = crossover(pais, qtd_filhos)
        mutantes = mutacao(filhos)
        geracao[0:pais.shape[0], :] = pais
        geracao[pais.shape[0]:, :] = mutantes
        
    fitness_max = npy.where(fitness == npy.max(fitness))
    parameters.append(geracao[fitness_max[0][0],:])
    return parameters, fitness_historico


parameters, fitness_historico = otimizar(peso, valor, populacao_inicial, qtd_solucoes, qtd_geracoes, mochila_peso_max)
print('A melhor solução encontrada para o problema foi: \n{}'.format(parameters))
selected_items = n_item * parameters


fitness_media = [npy.mean(fitness) for fitness in fitness_historico]
fitness_maximo = [npy.max(fitness) for fitness in fitness_historico]
plt.plot(list(range(qtd_geracoes)), fitness_media, label = 'Fitness Médio')
plt.plot(list(range(qtd_geracoes)), fitness_maximo, label = 'Fitness Máximo')
plt.legend()
plt.title('Fitness através das gerações')
plt.xlabel('Gerações')
plt.ylabel('Fitness')
plt.show()
print(npy.asarray(fitness_historico).shape)
